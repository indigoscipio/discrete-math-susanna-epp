Test yourself

1. when an algorithm statement of the form x:=e is executed, ___
answer: variable x is assigned with the value of e, the value is stored in the emory location

2. consider an algorithm statement of the following form:

if (cond)
then s1
else s2

when such a statement is executed, the truth or falsity of the condition is evaluatd.
if condition is true ___
if the condition is false, ___

answer: s1 is evaluated, s2 is evaluated

3. consider an algorithm  statement of the following
while (condition)
[loop body]
end while

when such a statement is executed, the truth or falsity of the condition is evaluated.
If the condition is true -__, if the condition is false, ___
answer: loop body is executed in order, go to next cond statement

4. Consider an algorithm statement of the following form.

for variable :=initial expression to final expression.
  [statements that make up the body of the loop]
  next (same) variable 

When such a statement is executed, variable is set 
equal to the value of the initial expression, and a 
check is made to determine whether the value of 
variable is less than or equal to the value of final 
expression. If so, ___ . If not, ___ .
answer: loop body is run and variable is increased by 1 until it reaches final expression, loop ends

5. given a nonnegatiev integer a and positive integer d the division algorithm computes
q and r with n = dq + r and 0 <= r < d
answer: the quotient q 
keep dividing a by d until the remainder is less than or equal to d
returns the final quotient and the remainder

6. given integers a and b, not both zero, gcd(a,b) is the integer d that satisfies the following two conditions;
d divides a, d divides b, there is a common divisor c where c <= d and c | a and c | b

7. if r is a positive intger, then gcd(r,0) is r

8. if a and b are integers not both zero and if q and r are nonnegative integeres such that a = bq + r, then
gcd (a,b) = gcd(b,r)

9. given the positive integers a and b with a > b, the euclidian algorithm computes
the GCD of A,B 

find the value of z when each of the algorithm segments in 1 and 2 is executed

1.
i:=2
if (i > 3 or i <= 0)
then z:= 1
else z:= 0

answer:
first assignment, i = 2
check if (2 > 3 (f) or 2 <= 0 (f)) - evaluates to false
z = 0 is executed, therefore z = 0

2.
i:=3
if(i<=3 or i>6)
then z:= 2
else z=0
answer:
initial variable assignment, i = 3
next check if (3<=3 (t) or 3>6 (f)) -> evaluates to true
z:=2 is executed - therefore z = 2

3. consider the following algorithm segment

if x . y > 0
then do
y := 3 . x
x := x + 1
end do
z = x . y

find the value of z if prior to execution x and y have the values given below
a. x = 2, y = 3, z = ??

answer:
check if 2 . 3 > 0 - true
y = 3.3 = 9
x = 2 + 1 = 3
z = 3 . 9 = 27
therefore z = 27

b. x = 1, y = 1
answer:
check if 1.1 > 0 - true
y = 3 .1 = 3
x = 1 + 1 = 2
z = 2 . 3 = 6
therefore z = 6


find the values of a and e after execution of the loops in 4 and 5 by first making trace tables for them

4.
a:=2
for i := 1 to 3
a:= 3a + 1
next i

Trace table
Iteration 0 (initial, before the loop runs)
i = unassigned
a = 2

Iteration 1
i = 1
a = 3.2 + 1 = 7

Iteration 2
i = 2
a = 3.7 + 1 = 22

iteration 3
i = 3
a = 3 . 22 + 1 = 67

i reaches or equal to 3, loop stops, evaluate final a
therefore final a = 67


5.
e:=2, f:=0
for k:=1 to 3
e:=e.k
f:= e+f
next k

Trace table
Iter 0 (initial, before loop is executed)
k = unassigned
e = 2
f = 0

Iter 1
k = 1
e = 2 . 1 = 2
f = 2 + 0 = 2

iter 2
k = 2
e = 2 . 2 = 4
f = 4 + 2 = 6

iter 3
k = 3
e = 4 . 3 = 12
f = 12 + 6 = 18

k reaches 3, loop stops
therefore e = 12 and f = 18


make a trace table to trace the action of algorithm 4.10.1 for the input variables given in 6 and 7
Algorithm 4.10.1  Diviison Algorithm

r = a, q = 0
while (r >= d)
r:= r - d
q:= q + 1
end while

6. a = 26, d = 7
Trace table
Iter 0 (initial before the loop runs)
a = 26
d = 7
r = 26
q = 0

Iter 1
check if r (26) >= d (7) - true, runs loop body
a = 26
d = 7
r = 26 - 7 = 19
q = 0 + 1 = 1

Iter 2
Check if r (19) >= d (7) - true, runs loop body
a = 26
d = 7
r = 19 - 7 = 12
q = 1 + 1 = 2

iter 3
check if r (12) >= d (7) - true, runs loop body
a = 26
d = 7
r = 12 - 7 = 5
q = 2 + 1 = 3

iter 4
check if r (5) >= d (7) - false, loop body stops
evaluates final result = quotient = 3, reminder = 5


7. a = 59, d = 13
Trace table
Iter 0 (initial before the loop runs)
a = 59
d = 13
r = 59
q = 0

Iter 1
check if r (59) >= d (13) - false, run loop body
a = 59
d = 13
r = 59 - 13 = 46
q = 0 + 1 = 1

Iter 2
check if r (46) >= d (13) - false, run loop body
a = 59
d = 13
r = 46 - 13 = 33
q = 1 + 1 = 2

Iter 3
check if r (33) >= d (13) - false, run loop body
a = 59
d = 13
r = 33 - 13 = 20
q = 2 + 1 = 3

Iter 4
check if r (20) >= d (13) - false, run loop body
a = 59
d = 13
r = 20 - 13 = 7
q = 3 + 1 = 4

Iter 5
check if r (7) >= d (13) - true, loop body stops, return final result
a = 59
d = 13
r = 7
q = 4

The folowing algorithm segment makes a change;
given an amount of money a between 1c and 99c
it determines a breakdown of A into quarters (q)
dimes (d), nicels (n), and pennies (p)

q:= A div 25
A:= A mod 25
d:= A div 10
A:= A mod 10
n:= A div 5
p:= A mod 5


a. Trace this algorithm segment for A = 69
input = 69c

A = 69
q:= 69 div 25 = 2
A:= 69 mod 25 = 19
d:= 69 div 10 = 6
A:= 69 mod 10 = 9
n:= 69 div 5 = 13
p:= 69 mod 5 = 4

final result:
q=2, d=6, n=13, p=4


b. trace this algorithm segment for A = 87
input = 87

q:= 87 div 25 = 3
A:= 87 mod 25 = 12
d:= 87 div 10 = 8
A:= 87 mod 10 = 7
n:= 87 div 5 = 17
p:= 87 mod 5 = 2

final result:
q=3, d=8, n=17, p=2

find the greatest common divisor of each of the pairs of integer 9 - 12
(use any methods you wish)
9. 27 and 72
answer: gcd=9
27 / 9 = 3
72 / 9 = 8

10. 7 and 21
answer: gcd = 7

11. 5 and 9
answer: gcd = 1

12. 48 and 54
answer: gcd = 6
48/2 = 12 /3 = 4
54/2 = 27 /3 = 9

make trace table of euclidian algorithm to calcualte the greatest common divisor
of each pairs of integers in 13 - 16
13. 1,188 and 385
A = 1188
B = 385

a = A = 1188
b = B = 385
r = 385

while b does not equal to 0
r:= a mod b
a:= b
b:= r
end while
gcd:= a

iter 0
a = 1188
b = 385
r = 385

b does not equal to 0? - true, runs loop body
r = 1188 mod 385 = 33
a = 385
b = 33

iter 1
b does not equal to 0? - true, runs loop body
r = 385 mod 33 = 22
a = 33
b = 22

iter 2
b does not equal to 0? - true, runs loop body
r = 33 mod 22 = 11
a = 22
b = 11

iter 3
b does not equal to 0? - true, runs loop body
r = 11 mod 22 = 11
a = 11
b = 11

iter 4
b does not equal to 0? - true, runs loop body
r = 0
a = 11
b = 0

iter 5
b does not equal to 0? - false, function body stops
returns gcd = a = 11


14. 509 and 1177
A = 509
B = 1177

Iter 0
a = A = 509
b = B = 1177
r = 1177

Iter 1
b does not equal to 0? - true, runs loop body
r = 509 mod 1177 = 509
a = 1177
b = 509

Iter 2
b does not equal to 0? - true, runs loop body
r = 1177 mod 509 = 159
a = 509
b = 159

Iter 3
b does not equal to 0? - true, runs loop body
r = 509 mod 159 = 32
a = 159
b = 32

Iter 4
b does not equal to 0? - true, runs loop body
r = 159 mod 32 = 31
a = 32
b = 31

Iter 4
b does not equal to 0? - true, runs loop body
r = 32 mod 31 = 1
a = 31
b = 1

Iter 5
b does not equal to 0? - true, runs loop body
r = 31 mod 1 = 0
a = 1
b = 0

Iter 6
b does not equal to 0? - false, function body stops
return gcd = a = 1

15. 832 and 10933
A = 832
B = 10933

Iter 0
a = A = 832
b = B = 10933
r = 10933

Iter 1
b does not equal to 0? - true, runs loop body
r = 832 mod 10933 = 832
a = 10933
b = 832

Iter 2
b does not equal to 0? - true, runs loop body
r = 10933 mod 832 = 117
a = 832
b = 117

Iter 3
b does not equal to 0? - true, runs loop body
r = 832 mod 117 = 13
a = 117
b = 13

Iter 4
b does not equal to 0? - true, runs loop body
r = 117 mod 13 = 0
a = 13
b = 0

Iter 5
b does not equal to 0? false
return final result -> gcd = a = 13

16. 4131 and 2431
A = 4131
B = 2431

Iter 0
a = A = 4131
b = B = 2431
r = 2431

Iter 1
b does not equal to 0? - true, runs loop body
r = 4131 mod 2431 = 1700
a = 2431
b = 1700

Iter 2
b does not equal to 0? - true, runs loop body
r = 2431 mod 1700 = 731
a = 1700
b = 731

Iter 3
b does not equal to 0? - true, runs loop body
r = 1700 mod 731 = 238
a = 731
b = 238

Iter 3
b does not equal to 0? - true, runs loop body
r = 731 mod 238 = 17
a = 238
b = 17

Iter 4
b does not equal to 0? - true, runs loop body
r = 238 mod 17 = 0
a = 17
b = 0

Iter 5
b = 0, returns gcd = a = 17


use euclidian algorithm to hand calculate gcd of each for the input
variables given in 17 - 19

17. 1001 and 871
gcd(1001, 871)
step 1 - divide 1001 by 871
divisor = 871
quotient = 1
remainder = 130
Thus 1001 = 871 . 1 + 130, hence gcd(1001,871) = gcd(871,130) by lemma 4.10.2

step 2 - divide 871 by 130
divisor = 130
quotient = 6
remainder = 91
Thus 871 = 130 . 6 + 91, hence gcd(871,130) = gcd(130,91) by lemma 4.10.2

step 3 - divide 130 by 91
divisor = 91
quotient = 1
remainder = 39
Thus 130 = 91 . 1 + 39, hence gcd(130,91) = gcd(91,39) by lemma 4.10.2

step 4 - divide 130 by 91
divisor = 91
quotient = 1
remainder = 39
Thus 130 = 91 . 1 + 39, hence gcd(130,91) = gcd(91,39) by lemma 4.10.2

step 5 - divide 91 by 39
divisor = 39
quotient = 2
remainder = 13
Thus 91 = 39 . 2 + 13, hence gcd(91,39) = gcd(39,13) by lemma 4.10.2


step 6 - divide 39 by 13
divisor = 13
quotient = 3
remainder = 0
Thus 39 = 13 . 3 + 0, hence gcd(39,13) = gcd(13,0) by lemma 4.10.2

Therefore gcd(1001, 871) = 13


18. 5859 and 1232
gcd(5859, 1232)
step 1 - divide 5859 by 1232
divisor = 1232
quotient = 4
remainder = 931
Thus 5859 = 1232 . 4 + 931, hence gcd(5859,1232) = gcd(1232,931) by lemma 4.10.2

step 2 - divide 1232 by 931
divisor = 931
quotient = 1
remainder = 301
Thus 1232 = 931 . 1 + 301, hence gcd(1232,931) = gcd(931,301) by lemma 4.10.2

step 3 - divide 931 by 301
divisor = 301
quotient = 3
remainder = 28
Thus 931 = 301 . 3 + 28, hence gcd(931,301) = gcd(301,28) by lemma 4.10.2

step 4 - divide 301 by 28
divisor = 28
quotient = 10
remainder = 21
Thus 301 = 28 . 10 + 21, hence gcd(301,28) = gcd(28,21) by lemma 4.10.2

step 4 - divide 28 by 21
divisor = 21
quotient = 1
remainder = 7
Thus 28 = 21 . 1 + 7, hence gcd(28,21) = gcd(21,7) by lemma 4.10.2

step 5 - divide 21 by 7
divisor = 7
quotient = 3
remainder = 0
Thus 21 = 7 . 3 + 0, hence gcd(21,7) = gcd(7,0) by lemma 4.10.2
therefore gcd = 7


19. 1570 and 488
gcd(1570, 488)
step 1 - divide 1570 by 488
divisor = 488
quotient = 3
remainder = 106
Thus 1570 = 488 . 3 + 106, hence gcd(1570,488) = gcd(488,106) by lemma 4.10.2

step 2 - divide 488 by 106
divisor = 106
quotient = 4
remainder = 64
Thus 488 = 106 . 4 + 64, hence gcd(488,106) = gcd(106,64) by lemma 4.10.2

step 3 - divide 106 by 64
divisor = 64
quotient = 1
remainder = 42
Thus 106 = 64 . 1 + 42, hence gcd(106,64) = gcd(64,42) by lemma 4.10.2

step 4 - divide 64 by 42
divisor = 42
quotient = 1
remainder = 22
Thus 64 = 42 . 1 + 22, hence gcd(64,42) = gcd(42,22) by lemma 4.10.2

step 5 - divide 42 by 22
divisor = 22
quotient = 1
remainder = 20
Thus 42 = 22 . 1 + 20, hence gcd(42,22) = gcd(22,20)  lemma 4.10.2

step 6 - divide 22 by 20
divisor = 20
quotient = 1
remainder = 2
Thus 22 = 20 . 1 + 2, hence gcd(22,20) = gcd(20,2) by lemma 4.10.2

step 7 - divide 20 by 2
divisor = 2
quotient = 10
remainder = 0
Thus 20 = 2 . 10 + 0, hence gcd(20,2) = gcd(2,0) by lemma 4.10.2



In 20 and 21 trace the action of algorithm 4.10.2 to deter
mine whether the integers are relatively prime.

Definition: Integers a and b are said to be relatively prime
if, and only if, their greatest common divisor is 1

20. 4617 and 2563
A = 4617
B = 2563

Iter 0
a = A = 4617
b = B = 2563
r = 2563

Iter 1
b does not equal to 0? - true, runs loop body
r = 4617 mod 2563 = 2054
a = 2563
b = 2054

Iter 2
b does not equal to 0? - true, runs loop body
r = 2563 mod 2054 = 509
a = 2054
b = 509

Iter 3
b does not equal to 0? - true, runs loop body
r = 2054 mod 509 = 18
a = 509
b = 18

Iter 4
b does not equal to 0? - true, runs loop body
r = 509 mod 18 = 5
a = 18
b = 5


Iter 5
b does not equal to 0? - true, runs loop body
r = 18 mod 5 = 3
a = 5
b = 3

Iter 6
b does not equal to 0? - true, runs loop body
r = 5 mod 3 = 2
a = 3
b = 2

Iter 7
b does not equal to 0? - true, runs loop body
r = 3 mod 2 = 1
a = 2
b = 1

Iter 8
b does not equal to 0? - true, runs loop body
r = 2 mod 1 = 0
a = 1
b = 0

Iter 8
b does not equal to 1? - true, stops loop body
returns gcd = a = 1
therefore 417 and 2563 are relatively prime since their gcd is 1

21. 34391 and 6728
A = 34391
B = 6728

Iter 0
a = A = 34391
b = B = 6728
r = 6728

Iter 1
b does not equal to 0? - true, runs loop body
r = 34391 mod 6728 = 751
a = 6728
b = 751

Iter 2
b does not equal to 0? - true, runs loop body
r = 6728 mod 751 = 720
a = 751
b = 720

Iter 3
b does not equal to 0? - true, runs loop body
r = 751 mod 720 = 31
a = 720
b = 31

Iter 4
b does not equal to 0? - true, runs loop body
r = 720 mod 31 = 7
a = 31
b = 7

Iter 5
b does not equal to 0? - true, runs loop body
r = 31 mod 7 = 3
a = 7
b = 3

Iter 6
b does not equal to 0? - true, runs loop body
r = 7 mod 3 = 1
a = 3
b = 1

Iter 7
b does not equal to 0? - true, runs loop body
r = 3 mod 1 = 0
a = 1
b = 0

Iter 8
b does not equal to 0? - false, stops body
evaluates final result = gcd = a = 1
therefore 34391 and 6728 are relatively prime since it has gcd of 1

22. Prove that for all positive integers a and b,
a|b if, and only if, gcd(a, b) = a.

(Note that to prove “A if, and only if, B,” you need to prove “if A then B” and “if B then A.”)

answer:
first prove if a | b then gcd(a,b) = a
by the definition of divisibility, a | b can be writte nas b = aq for some integer q
gcd (a,b) = a
a | a
a is a cmmon divisor of a and b

let c be any common divisor of a and b
c | a and c | b
c must be <= a in for a to be divisible by c
therefore gcd(a,b) = a


then prove if gcd(a,b) = a then a | b
d | a and d | b
c <= d
gcd(a,b) | a -> a | a
gcd(a,b) | b = a | b

therefore the statement is true


23.

a. Prove that if a and b are integers, not both zero, 
and d = gcd(a, b), then a/d and b/d are integers 
with no common divisor that is greater than 1.

answer:
a = b = nonzero integer
d = gcd(a,b)

a/d = b/d = integers with no common divisor that is greater than 1
d | a and d | b
a = d . k for some integer k
b = d . m for some integer m

a/d = d | a
b/d = d | b

d divides a and band therefore d is a common divisor

gcd(a/d, b/d) = 1
let x = a/d
let y = b/d
let c = common divisor of x and y
by definition, c | x and c | y

c | a/d -> a/d = c . q for some integer q
multiply both sides by d
(a/d) . d = (c . q) . d
a = (cd) . q

c | b/d -> b/d = c . r for some integer r
multiply both sides by d
b = c . r .d
b = (cd) . r

since d = gcd(a,b) this means  d is the greatest common divisor
and that any other common divisor must be less than or equal to d
therefore,  cd <= d

now since a and b is nonzero positive integer, it follows that d is a positive integer
so c <= 1 therefore gcd of a/d and b/d = 1



b. Write an algorithm that accepts the numerator 
and denominator of a fraction as input 
and produces as output the numerator and 
denominator of that fraction written in lowest 
terms. (The algorithm may call upon the 
Euclidean algorithm as needed.)


algorithm body

input: [n, d] where n = numerator and d = denuminator, n and d are both integers and d does not equal 0
; find the gcd of both numerator and denominator
a:=n
b:=d

while (b does not equal 0)
r:= a mod b
a:= b
b:= r

end while
gcd:= a

; divide the numerator and denominator by the gcd
; the result is nn and nd, return it
nn:= n / a
nd:= d / a

output: [nn, nd] where nn = new numerator (in lowest term), nd = new denuminator (lowest term)


24. Complte the proof of lemma 4.10.2 by proving the following:
if a and b are any integers with b does not equal 0, q a nd r a re any integers such that

a = bq + r

then gcd(b,r) ,= gcd(a,b)

proof [dividede into 2 sections: 1 proof that gcd (a,b <= gcd(b,r))
2 proof that gcd(b,r) <= gcd(a,b). Since each gcd is less than or equal to the other, the two must be equal.]

1. gcd (a,b) <= gcd (b,r)