Test yourself
1. the base for a recursive definition of a set is ___
answer: a statement that the basic element belongs to a set

2. the recursion for a recursive definition of a set is ___
answer: a collection of rules stating how to build new sets from existing object in the set

3. the restrcition for a recursive definition of a set is __
answer: a statement that no object can belong to a set except those built from base case and recursion

4. one way to show that a given element is in a recursively defined set
is to start with an element or elements in the ___ and apply the rules from
the ___ until you obtain the given element
answer: base case, recursive case

5. To use structural induction to prove that every 
element in a recursively defined set S satisfies a 
certain property, you show that ___
and that, for each rule in the recursion, if ___  then ___
answer: the base case is true, the rule is applied for objects in the base case, the objects defined by the rule is also true

6.  A function is said to be defined recursively if, and 
only if ___
answer: its rule refers to itself

Exercise set 5.9
1. Consider the set of Boolean expressions defined in 
Example 5.9.1. Give derivations showing that each 
of the following is a Boolean expression over the 
English alphabet {a,b,c,...,x,y,z}

notes/from example 5.9.1:
~ = negation
V = OR
A = AND
I. Base: Each symbol of the alphabet is a Boolean expression.
II. Recursion: If P and Q are Boolean expressions, then the following are also Boolean expressions:
II(a) P A Q
II(b) P V Q
II(c) ~P
II(d) (P)
III. Restriction: There are no Boolean expressions over the alphabet other than those ob
tained from the base and the recursion.


a. ~p V (q A (r V ~s) )
answer: 
1. by I, the symbol p, q, r, and s is a boolean expression
2. by 1, II(c), ~p and ~s is a boolean expression
3. by 2, II(b), II(a), II(d) (r V ~s) is a boolean expression
4. by 3, II(d), II(a), (q A (r V ~s)) is a boolean expression
5. by 4, II(b), ~p V (q A (r V ~s)) is a boolean expression


b. (p v q) V ~((p A ~s) A r)
answer:
1. by I, p, q, r, and s is a boolean expression
2. by 1, II(c), ~s is a boolean expression
3. by 2, II(a), p A ~s is a boolean expression
4. by 3, II(a), II(b), II(d), ((p A ~s) A r) and (p v q) is a boolean expression
5. by 4, II(c), II(b), (p v q) V ~((p A ~s) A r) is a boolean expression


2. Consider the set C of parenthesis structures defined in Examples 5.9.2.
Give derivations showing that each of the following is in C.
notes from example 5.9.2
I. Base: () is in C.
II. Recursion:
II(a) If E is in C, so is (E).
II(b) If E and F are in C, so is EF.
III. Restriction: No parenthesis structures are in P other than those obtained from the base and the recursion.


a. ()(())
answer:
1. by I, () is in C
2. by 1, IIa, (()) is in C
3, by 2, IIb, ()(()) is in C

b. (())(())
answer:
1. by I, () is in C
2. by 1, IIa, (()) is in C
3. by 2, IIb, (())(()) is in C


3. let S be the set of all strings over a finite set A and let a,b, and c be any characters in A.
a. using theorem 5.9.1 but not theorem 5.9.3 or 5.9.4, show that (ab)c = a(bc)
note from theorem 5.9.1
Theorem 5.9.1  Characters Are Strings
If A is a finite set and S is the set of all strings over A, then every character in A is a string in S.
proof:
(1) Suppose c is any character in A.
(2) By part I of the definition of string, (lambda) is a string in S.
(3) By part II(a) of the definition of string, (lambda)c is a string in S.
(4) By part I of the definition of string, (lambda)c = c.
(5) Thus c is a string in S.

answer:
let a,b, and c be any characters in A.
we need to show that (ab)c = a(bc)
1. since a,b,and c are characters in A, therefore each of them is a string in S
2. since a and b are strings in s, then we can concatenate ab. So ab is in S
3. since ab is a string and c is a string, (ab)c is in S
4. likewise, since a is a string and bc is a string, a(bc) is in s
5. since both (ab)c and a(bc) represent the same sequence and string they must be equal


b. show that ab is a string in S. then us the result of part (a) to conclude that a(bc) is a string in S.
(this exercise shows that parentheses are not needed when writing the string abc)
answer:
1. since a,b,and c are characters in S, each of them is a string in S
2. since a and b are strings in s then we can concatenate it inti ab , so ab is in S
3. since ab is a string and c is a chracter, we can concatenate it into (ab)c, so (ab)c is in S
4. from the result of a, we know that (ab)c = a(bc)
5. therefore since (ab)c is a string we can conclude a(bc) is also in s

4. consider the MIU-system discussed in example 5.9.4. give derivations showing that each of the following is in the MIU system.
example 5.9.4
I. Base: M I is in the M I U-system.
 II. Recursion:
II(a)  If x I is in the M I U-system, where x is a string, then x I U is in the M I U-system. 
(In other words, you can add a U to any string that ends in I. For example, since 
M I is in the system, so is M I U.)
II(b)  If M x is in the M I U-system, where x is a string, then M x x is in the M I U-system. 
(In other words, you can repeat all the characters in a string that follow an initial 
M. For example, if M U I is in the system, so is M U I U I.)
II(c)  If x I I I y is in the M I U-system, where x and y are strings (possibly null), then x 
U y is also in the M I U-system. (In other words, you can replace I I I by U. For 
example, if M I I I I is in the system, so are M I U and M U I.)
II(d)  If x U U y is in the M I U-system, where x and y are strings (possibly null), then  
x U y is also in the M I U-system. (In other words, you can replace U U by U. For 
example, if M I I U U is in the system, so is M I I U.)

a. M I U I
answer:
1. start with M I since its the base case
2. by rule IIc, we can repeat it into M I I
3. by rule IIc, we can repeat it into M I I I I 
3. by rule IIc, we can repeat it into M I I I I I I I I


b. M U I I U
answer:
1. start with M I since it's the base case
2. by rule 2c, we can repeat the I into M I I
3. by rule 2c, we can repeat the I in to M I I I I
4. by rule 2c, we can repeat the I into M I I I I I I I I
5. by rule 2b, turn the first triple I into U = M U I I I I I
6. by rule 2b, turn the last triple I into U =  M U I I U

5. the set of arithmetic expression over the real numbers can be defined recursively as follows:
I. base : each real number r is an arithmetic expression
II. recursion: if u and v are arithmetic expr, then the following are also arithmetic expr
IIa. (+u)
IIb. (-u)
IIc. (u + v)
IId. (u - v)
IIe. (u * v)
IIf. (u / v)
III. restriction: there are no arithmetic expr over the real nombers other than those obtaind from I and II
note that the artihemtic expr u/v is allowed to be 
an arithmetic expression even though the value 
of v may be 0.)

Give derivations showing that each of the following is an arithmetic expression.
a. ((2 . (0.3 - 4.2)) + (-7))
answer:
1. by rule I, 2, 0.3, 4.2, and 7 is a real number r, and is therefore an arithmetic expression
2, by 1 and IIb, -7 is an arithmetic expression
2. by 1 and IId, (0.3 - 4.2) is an arithmetic expression
3. by 1, 3, and IIe, (2 * (0.3 - 4.2)) is an arithmetic expression
4. by 2, 4, and  rule IIc, ((2 * (0.3 - 4.2)) + (-7)) is an arithmetic expression

b. ((9 . (6.1+2))/((4-7).6))
answer:
1. by rule I, 9,6,1,2,4,7 are real number r and is therefore an arithmetic expression
2. by 1 and IIe, 6 * 1 is an arithmetic expression
3. by 2 and IIc, 6 * 1 + 2 is an arithmetic expression
4. by 1 and rule IId, 4 - 7 is an arithmetic expression
5. by 3, 4, and rule IIe, (9 * (6 . 1 + 2)) and ((4 - 7) * 6) is an arithmetic expression
6. by rule IIf, ((9 . (6.1+2))/((4-7).6)) is an arithmetic expression

6. let S be a set of integers defined recursively as follows:
I. base: 5 in S
II. Recursion:  Recursion: Given any integer n in S, n + 4 is in S
III. restriction: no integers are in S other than those derived from rules I and II above.

use structural induction to prove that for every integer n in S, n mod 2 = 1
answer:

proof by structural induction
base case -> show that p(n) is true for each integer n in the base for S
the only object is 5 in S, so 5 mod 2 = 1 is true since it leaves a reminder of 1

inductive hypothesis: assume that for an arbitrary integer n in S, the property n mod 2 = 1 is true
so n = 2k + 1

we must show that p(n+4) is true, that is n+4 mod 2 = 1 is true
we can rewrite n+4 mod 2 = 1 as
n + 4 = 2k + 1 -> since earlier we assumed n = 2k+1 we can substitute
2k+1+4
2 (k + 2) + 1
therefore proven

7. Define a set S of strings over the set {0, 1} recursively as follows:
I. base: 1 E (is an element of ) S
II. recursion: if s E S, then
IIa 0s E S
IIb 1s E S
III. restriction: nothing in S other than objects defined in I and II above
use structural induction to prove that every string in S ends in a 1

answer:
proof by structural induction
base case -> p(s) = every string ends in S ends in a 1
since the base case is 1 E S, then 1 is the only emeent in S and it ends in a 1 so true

inductive hypothesis: assume that a string s in S ends in a 1

show that the recursive rules are true
0s E S -> the last character here is 1 since we assumed in p(s). the new string s created by prepending 0 to string s
1s E S -> the last character here is 1 since we assumed in p(s). the new string s is created by prepending 1 to string s
therefore proven

8. define a set S of string over the set {a,b} recursively as follows:
I. base: a E (is an element of ) S
II. recursion: if s E S, then
IIa. sa E S
IIb. sb E S
III. restriction: nothing in S other than objects defined in I and II above
use structural induction to prove that every string in S begins with an a

answer:
proof by structural induction
base case -> p(s) =  every string in S begins with an a
since the base case we only have one string a in S, S begins and ends with a. Therefore the base case is true

inductive hypothesis: assume that a string s in S begins with an a

we must show the recursive step is correct
sa E S -> the first character here is s. but we assumed earlier that string s always begins with an a.
the new string s is created by appending a to the end of string s. so sa begins with an a. Therefore true

sb E S -> the first character here is s. but we assumed earlier that string s always begins with an a.
the new string s is created by appending b to the end of string s. so sa begins with an a. Therefore true

since we know both recursive cases are true then its proven

9. define a set S of strings over the set {a,b} recursively as follows:
I. base: l (empty string) E (is an element of) s
II. recursion: if s E S, then
IIa. bs E S
IIb. sb E S
IIc. saa E S
IId. aas E S
III. resctiction: nothing is in S other than objects defined in I and II above
use structural induction to prove that every string in S contains an even number of a's

answer:
proof by structural inductoin
base case: p(s) -> every string in S contains an even number of a's
since in the base case only contains empty string, therefore it contains an even number of a's (0 is even)

inductive hypothesis: assume that every string in S contains an even number of a's

we must show the recursive cases are true
bs E S -> here we are prepending b into s.
Since in IH we assumed string s has an even number of a's therefore this is even because b is not a and it doesn't count

sb E S -> here we are appending b into s.
Since in IH we assumed string s has an even number of a's therefore this is even because b is not a and it doesn't count

saa E S -> here we are appending two as into s
Since in IH we assumed string s has an even number of a's, therefore this is even because even + 2a (even) = even by parity

aas E S -> here we are prepending two as into s
Since in IH we assumed string s has an even number of a's, therefore this is even because 2a (even) + even = even by parity

therefore proven

10. define a set S of strings over the set of all integers recursively as follows:
I. base: 1 E S, 2 E S, ... 9 E S
II. recursion: if s E S and t E S then
IIa s0 E S
IIb st E S
III restriction: nothing is in S other tha nobjects defined in I and II above

use structural induction to prove that no string in S represents an integer with a leading zero

answer:
proof by structural induction
base case: since 1 - 9 the a single digit number with no leading zero, therefore they don't contain zero

inductive hypothesis: no string in S represents an integer with a leading zero

we must show the recursive rules are true
s0 E S -> here we are appending 0 into string s. but since we assumed earlier that s doesn't contain integer with a leading zero
this means that s always starts with a non-zero integer (1 - 9)

st E S -> we are prepending the s into t. but since we assumed earlier that s doesn't contain integer with a leading zeor,
this means the first character is s. And we know s is  a non-zero integer (1 - 9)

threfore both casese aretrue and proven

11. define a set S of strings over the set of all integers recursively as follows:
I. base: 1 E S, 3 E S, 5 E S, 7 E S, 9 E S
II. recursion: if s E S and t E S then
IIa. st E S
IIb. 2s E S
IIc. 4s E S
IId. 6s E S
IIe. 8s E S

III. restriction: nothing is in S other than objects defined in I and II above

use structural induction to prove that eveyr string in S represents an odd integer when written in decimal notation

answer:
proof by structural induction
base case: 1,3,5 ... 9 is in S
since we know the sequence are odd integers and is written in decimal notation, threfore the base case is true

inductive hypothesis: assume that  eveyr string in S represents an odd integer when written in decimal notation is true

we must show the recursive rules are true
st E S -> here we are appending t into s. since we assumed every string in s is an odd integer written in decimal,
therefore t also odd integer written in decimal

2s E S -> here we are prepending 2 into s. since we assumed every string in s is an odd integer written in decimal,
therefore this is also an odd integer in decimal (21, 23, 25, 27.... is odd)

4s E S -> here we are prepending 2 into s. since we assumed every string in s is an odd integer written in decimal,
therefore this is also an odd integer in decimal (41, 43, 45, 47.... is odd)

6s E S -> here we are prepending 2 into s. since we assumed every string in s is an odd integer written in decimal,
therefore this is also an odd integer in decimal (61, 63, 65, 67.... is odd)

8s E S -> here we are prepending 2 into s. since we assumed every string in s is an odd integer written in decimal,
therefore this is also an odd integer in decimal (81, 83, 85, 87.... is odd)

therefore since all recursive cases are true its proven

12. define a set S of integers recursively as follows:
I. base: 0 E (is an element of) S, 5 E S,
II. recursion: if k E S and p E S, then
IIa. k + p E S
IIb. k - p E S
III. restriction: nothing is in S other than objects defined in I and II above

use structural induction to prove that every integer in S is divisible by 5
answer:
proof by structural induction

base case:
0 E S -> true because 0 is divisible by any number
5 E S -> true because 5 is divisible by 5

inductive hypothesis: assume that every integer in S is divisible by 5
k = 5m, p = 5n

we must show the recursive cases are true
k + p E S -> here we are adding a k with p - 0 or 5, in which both are divisble by 5
k + p = 5 (m+n)

k - p E S -> here we are subtracting a k with p - 0 or 5, in which both are divisble by 5.
anything divisble by 5 - anything divisble by 5 is always divisbly by 5 since its the common factor
k - p = 5 (m - n)

therefore both cases are true and therefore proven

13. define a set S of integers recursively as follows
I. base: 0 E S
II. recursion: if k E S, then 
IIa. k + 3  E S
IIb. k - 3 E S
III. restriction: nothing is in S other than objects defined in I and II above

use structural induction to prove that every integer in S is divisible by 3

answer:
proof by structural induction

base case:
0 -> true because 0 is divisible by any number

inductive hypothesis: assume that for abritary integer k in S, the property p(k) is true
in other words, assume that k is divisble by 3. this means we can write k = 3n where n is an integer

inductive step: we must show that the property holds for new integers created by recursive rules

case 1: k + 3 -> since we assumed k =3n we can substitute
3n + 3 = 3 (n+1) -> since n+1 is an integer therefore this is divisible by 5

case 2: k - 3 -> since we ssumed k = 3n we can substitute
3n - 3 = 3 (n-1) -> since n - 1 is an integer therefore it's also divisible by 5

since the property holds for both cases therefore its proven


15. 
