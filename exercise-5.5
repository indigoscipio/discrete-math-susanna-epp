Test yourself

1. a pre-condition for an algorithm is ___
and a post-condition for an algorithm is ___
answer:
a predicate that describes the initial state of the input variables for the algorithm
a predicate that describes the final state of the output variables for the algorithm


2.  A loop is defined as correct with respect to its 
pre- and post-conditions if, and only if, whenever 
the algorithm variables satisfy the pre-condition 
for the loop and the loop terminates after a finite 
number of steps, then ___
answer: the algorithm variables satify the post-condition for the loop

3. for each iteration of the loop, if a loop invariant is true before iteration of the loop,
then ___
answer: it is true after the iteration of the loop

4. given a while loop with guard G and a predicate i(n) if the folowing properties are true, then the loop is correct
with respect to its pre-and post conditions
a) the pre-cond for the loop implies that ___ before
the first iteration of the loop
b) for every integer k>= 0, if the guard g and the predicate i(k) are both true before an iteration of the loop,
then ___
c) after a finite number of iterations of the loop, ___
d) if N is the least number of iteration after which G is false and i(N) is true, then
the values of the algorithm variables will be as as specified ___
answer:
a) i(0) is true
b) l(k+1) is true after the iteration of the loop
c) the guard will eventually become false
d) in the post condition of the loop


exercise set 5.5
Exercises 1–5 contain a while loop and a predicate. In 
each case show that if the predicate is true before entry 
to the loop, then it is also true after exit from the loop.

1. loop:
while (m>=0 and m <= 100)
m:= m+1
n:= n-1
end while
predicate: m+n = 100

step 1: initialization
assume m+n = 100 before the loop begins
p(m,n) =  m+n = 100

step 2: maintenance
let m_old and n_old be the values of m and n at the start of an iteration
m_old + n_old = 100
m_old >= 0 and m_old <= 100

inside the loop
m_new = m_old + 1
n_new = n_old - 1

m_new + n_new = 100
= (m_old + 1) + (n_old - 1) = 100
= m_old + n_old = 100

therefore if the predicate is true before iteration, it remains true after iteration

step 3: termination
when the loop terminates, p(m,n) is still true because
the loop termintates when the while condition is false
that means either m < 0 or m > 100
The loop repeats while m is between 0 and 100 inclusive.
Because m keeps increasing, eventually m must exceed 100.
m will eventually exceed 100

2. loop:
while(m>= 0 and m<= 100)
m:=m+4
n:=n-2
end while
predicate: m+n is odd

step 1: initialization
assume m+n is odd before the loop begins
p(m,n) = m+n is odd

step 2: maintenance
let m_old and n_old be the values of m and n at the start of an iteration
so assume m_old + n_old is odd
m_old >= 0 and m_old <= 100

inside the loop
m_new = m_old + 4
n_new = n_old - 2

m_new + n_new is odd
= (m_old + 4) + (n_old - 2) is odd
= m_old + n_old + 2 is odd

since we assume m_old + n_old is old we can then substitute tha parity
= odd + 2 is odd
= odd + even is odd
since even + odd is alawys odd therefoer step 2 is true

step 3: termination
when the loop terminates, p(m,n) is still true because
since m+n was odd before the loop starts, and it never changed throughout the iteration,
we can conclude that ist still odd when the loop terminates


3. loop:
while (m>=0 and m<= 100)
m:= 3m
n:= 5n
end while
predicate: m^3 > n^2

step 1: initialization
assume m^3 > n^2 is true before the loop begins
p(m,n) -> m^3 > n^2

step 2: maintenance
let m_old and n_old be the values of m and n at the start of an iteration
assume m_old and n_old = m_old^3 > n_old^2
where m_old >=0 and m_old <= 100

then inside the loop
= m_new = 3 . m_old
= n_new = 5 . n_old

then we can substitute
m_new^3 > n_new^2
= (3 . m_old)^3 > (5 . n_old^2)
= 3^3 . m_old^3 > 5^2 . n_old^2
= 27 . m_old^3 > 25 . n_old^2

since we know that m_old^3 > n_old^2
multiplying both sides by 27 will hold
27 . m_old^3 > 27 . n_old^2

and since 27 >25 we know that
27. n_old^2 > 25 . n_old^2

therefore we know
27 . m_old^3 > 27 . n_old^2 > 25. n_old^2
therefore  if A > B and B > C then A > C by transivitiy so its true

step 3: termiation
when the loop terminates p(m,n) is still true because
since m^3 > n^2 was true before the loop starts and it never changed throughout the iteration
we can conclude that its still holds true even after the loop terminates

4. loop:
while (n >= 0 and n<= 100)
n:= n+1
end while
predicate: 2^n < (n+2)!

step 1: initialization
assume the predicate p(n) is true before the loop begins
p(n) = 2^n < (n+2)!

step 2: maintenance
let n_old be the values of n at the start of an iteration
2^n_old < (n_old+2)!
where n_old >= 100 and n_old <= 100

then inside of the loop
n_new = n_old + 1

then we can substitute
2^n_new < (n_new + 2)!
= 2^n_old+1 < ((n_old+1)+2)!
= 2 . 2^n_old < (n_old+3) . (n_old+2)!

focusing on 2 < (n_old+3)
since we know that n>= 0 and n<= 100
and the smallest value RHS can hold when n=0 is 3
so 2 < 3 therefore the inequality is true
therefore the inequality 2 . 2^n_old < (n_old+3) . (n_old+2)! holds


step 3: termination
when the loop terminates, p(n) is still tre because
since the predicate 2^n < (n+2)! was true before the loop starts and it never changed throughout the iteration
we can conclude that its still holds true even after the loop terminates

5. loop:
while (n>=3 and n<= 100)
n:= n+1
end while
predicate: 2n+1 <= 2^n

step 1: initialization
assume the predicate 2n+1 <= 2^n is true before the loop begins
p(n) -> 2n+1 <= 2^n

step 2: maintenance
let n_old be the values of n at the start of an iteration
so 2 . n_old + 1 <= 2^n_old
where 3 <= n_old <= 100

inside the loop
n_new = n_old + 1 (increment the index)

then run this predicate
2 . n_new + 1 < 2^n_new
= 2 . (n_old + 1) + 1 <  2^n_old+1
= 2 . n_old + 2 + 1 < 2 . 2^n_old
= 2 . n_old + 3  < 2 . 2^n_old

since we assumed 2 . n_old + 1 <= 2^n_old from IH,
we can multiply both sides by 2
4 . n_old + 2 <= 2 . 2^n_old

then we can compare
2 . n_old + 3 <= 4 . n_old + 2 
subtract 2 . n_old from both sides
3 <= 2 . n_old+2
subtract 2 from both sides
1 <= 2 . n_old
since we know n at a minimum is 3 we can substitute
1 <= 2 . 3
1 <= 6

since we know 2 . n_old + 3 <= 4 . n_old + 2 <= 2 . 2^n_old
therefore 2 . n_old + 3 <= 2 . 2^n_old equality holds

step 3: termination
when the loop terminates, p(n) is still tre because
since the predicate 2n+1 <= 2^n was true before the loop starts and it never changed throughout the iteration
we can conclude that its still holds true even after the loop terminates

exercises 6–9 each contain a while loop annotated with a 
pre- and a post-condition and also a loop invariant. In each 
case, use the loop invariant theorem to prove the correct
ness of the loop with respect to the pre- and post-conditions.

6.
[pre-condition: m is a nonnegative integer, x is a real number, i = 0 and exp = 1]
while (i does not equal m) 
1. exp:=exp.x
2. i:=i+1
end while
[post condition: exp=x^m]
loop invariant: I(n) is "exp = x^n and i = n"

answer:
let the loop invariant be  I(n) is "exp = x^n and i = n"
let the guard G be (i does not equal m)  

I. BASIS PROPERTY:
[I(0) is true before the first iteration of the loop]
I(0) is "exp = x^0 and i = n" -> exp = 1 and i = 0, therefore it is true before the first iteration of the loop

II. INDUCTIVE PROPERTY:
[if G AND I(k) is true before a loop iteration where k>=0,
then I(k+1) is true after the loop iteration]

suppse k is a nonnegative int such that G AND I(k) is true before iteration of the loop
then as execution reaches the top of the loop, i does not equal m and exp = x^k
since i does not equal m the guard is passed and statement 1 is executed
before execution of statement 1,

exp_old = x^k

then execution of statement 1 has the following effect
exp_new = exp_old . x
= x^k . x
= x^k+1

before statement 2 is executed
i_old = k
afer execution of statement 1 it becomes
i_new = i_old + 1

hence after the loop iteration, the statement i(k+1) (i = k+1 and exp=x^k+1) is therefore true

III. EVENTUAL FALSITY OF THE GUARD
[after a finite number of iterations of the loop, G becomes false]
the guard G is the condition i does not equal m, and m is a nonnegative integer
by 1 and 2 we know that
for every integer n>= 0, if the loop is iterated n times, then i = n and exp = x^n
so after m iterations of the loop i will eventually become m. thus G becomes false after m iterations of the loop

IV. CORRECTNESS OF THE POST-CONDITION
[if N is the least number of iterations after which G is false and I(N) is true, then the value of the algorithm
variables will be as specified in the post-condition of the loop]

when the loop terminates
the guard G becomes false, so i = m
the loop invariant I(N) holds: x^N and i = N
since i = m and i = n we conclude N = m
thus exp = x^N = x^m satisfying the post condition

thus proven

7.
[pre-condition: largest = A[1] and i = 1]
while (i does not equal m)
1. i:=i+1
2. if A[i] > largest then largest:= A[i]
end while
[post condition: largest = maximum value of A[1], A[2], A[3], A[4], ... A[m]]
loop invariant: I(n) is "largest = maximum value of A[1], A[2], ... A[n+1] and i = n + 1"

answer:
let the loop invariant be I(n) is "largest = maximum value of A[1], A[2], ... A[n+1] and i = n + 1"
let the guard G be (i does not equal m)  

I. BASIS PROPERTY:
[I(0) is true before the first iteration of the loop]
I(0) is largest = maximum value of A[0+1] and i = 0 + 1
= A[1] and i = 1
therefore it is true befoer the first iteration of the loop, satisfying the precondition.

II. INDUCTIVE PROPERTY:
[if G AND I(k) is true before a loop iteration where k>=0,
then I(k+1) is true after the loop iteration]

suppse k is a nonnegative int such that G AND I(k) is true before iteration of the loop
then as execution reaches the top of the loop, i does not equal m
and I(k) is "largest = maximum value of A[1], A[2], ... A[k+1]
since i does not equal m the guard is passed and statement 1 is executed
before execution of statement 1,

largest_old = maximum value of A[1]_old, A[2]_old, ..., A[n+1]

then execution of statement 1 has the following effect
i_old = k + 1

after execution of statement 1 it becomes
i_new = i_old + 1
= k + 1 + 1
= k + 2

before statement 2 is executed
A[i] > largest_old then largest_old:= A[i]
largest_new = maximum value of A[1]_new, A[2]_new, ... , A[k+2]

case 1: A[k+2] <= largest_old
don't update largest
but its still the maximum value of A[1]...,A[k+2] because A[k+2] isn't bigger than the previous max

case 2: A[k+2] > largest_old
set largest:= A[k+2]
now largest = maximum value of (A[1]),...,A[k+2]

in both cases i = k+2 and largest = maximum value of A[1],...,A[k+2]

III. EVENTUAL FALSITY OF THE GUARD
[after a finite number of iterations of the loop, G becomes false]
the guard G is the condition i does not equal m, and m is nonnegative integer/final array index
each iteration increases the index by adding 1. and i = 1 by the precondition
after m iterations of the loop i will eventually become m. thus G becomes false after m iterations of the loop

IV. CORRECTNESS OF THE POST-CONDITION
[if N is the least number of iterations after which G is false and I(N) is true, then the value of the algorithm
variables will be as specified in the post-condition of the loop]

when the loop terminates
the guard G becomes false, so i = m eventually
the loop invariant "largest = maximum value of A[1], A[2], ... A[n+1] and i = n + 1"
thus m = n + 1
then the provided post-condition
largest = maximum value of A[1], A[2], A[3], A[4], ... A[m]] it true

thus proven

8. 
[pre-condition: sum = A[1] and i = 1]
while (i does not equal m)
1. i:=i+1
2. sum:= sum+a[i]
end while
[post condition: sum =  A[1] + A[2] + ... + A[m]]
loop invariant: I(n) is "i = n+1 and sum = A[1]+A[2]+...+A[n+1]"

answer:
let the loop invariant I(n) be i = n+1 and sum = A[1]+A[2]+...+A[n+1]
let the guard G be (i does not equal m)  

I. BASIS PROPERTY:
[I(0) is true before the first iteration of the loop]
I(0) is i = 0 + 1 and sum = A[1] -> i = 1 and sum = A[1]
therefore it is true before the first iteration of the loop

II. INDUCTIVE PROPERTY
[if G AND I(k) is true before a loop iteration where k>=0,
then I(k+1) is true after the loop iteration]

suppose k is a nonnegatiev integer such that G and I(k) is true before iteration of the loop
then as execution reaches the top of the loop, the guard is passed
i does not equal m and the invariant i = k + 1 and sum = A[1]+A[2]+...+A[k+1] is true

before the execution of statement 1
i_old = k + 1

after execution of statement 1
i_new = i_old + 1
i_new = k + 1 + 1
i_new = k + 2

before statement 2 is executed
sum_old = A[1]+A[2]+...+A[k+1]

after statement 2 is excecuted
sum_new = sum_old + A[k+2]
sum_new = A[1]+A[2]+...+A[k+1]+A[k+2]
sum_new = A[1]+A[2]+...+A[k+2]

thus this matches the invariant A[1]+A[2]+...+A[k+1+1]

III. EVENTUAL FALSITY OF THE GUARD
[after a finite number of iterations of the loop, G becomes false]
the guard G is the condition i does not equal m, and m is a nonnegative integer
since i starts and 1 (by the precondition) and on each iteration it increases by 1,
eventually i = m and the guard G will be false

IV. CORRECTNESS OF THE POST-CONDITION
[if N is the least number of iterations after which G is false and I(N) is true, then the value of the algorithm
variables will be as specified in the post-condition of the loop]

when the loop terminates the guard G will eventually becomes false
so i = m eventually
the loop invaraint  I(N) is "i = N+1 and sum = A[1]+A[2]+...+A[N+1]"
thus m = N + 1
then the provided post-condition sum =  A[1] + A[2] + ... + A[m] = sum =  A[1] + A[2] + ... + A[N+1] holds

thus proven

9.
[pre-condition: a = A and A is a positive integer]
while (a > 0)
a:=a-2
end while
[post condition: a=0 if A is even and a = -1 if A is odd]
loop invariant: I(n) is "Both a and A are even integers or both are odd integers and, in either case, a>= 1"

answer:
let the loop invariant I(n) be "Both a and A are even integers or both are odd integers and, in either case, a>= 1"
let the guard G be (a > 0)

I. BASIS PROPERTY:
[I(0) is true before the first iteration of the loop]
I(0) is "Both a and A are even integers or both are odd integers and, in either case, a>= 1"
since a = A and A is a positive integer, and same number have equal parity,
therefore it is true before the first iteration of the loop

II. INDUCTIVE PROPERTY
[if G AND I(k) is true before a loop iteration where k>=0, then I(k+1) is true after the loop iteration]

suppose k is a nonnegative integer such that G and I(k) is true before iteration of the loop
then as execution reaches the top of the loop, the guard is passed
a > 0 and is true and the invariant I(k) "Both a and A are even integers or both are odd integers and, in either case, a>= 1" is true

before the execution of statement 1
a_old and A both have the same parity (both even or odd)
a_old >= 1

after the execution of statement 1
a_new= a_old - 2
if a_old is even, it stays even because even - even is even
if a_old is odd, it stays odd because odd - even is odd
therefore a_new will have the same parity as A

III. EVENTUAL FALSITY OF THE GUARD
[after a finite number of iterations of the loop, G becomes false]
the guard G is the condition a is greater than 0 where it starts at a>=1
since on each iteration we decrement a by 2, it will eventually reach zero or below
and eventually the guard a > 0 will become false

IV. CORRECTNESS OF THE POST-CONDITION
[if N is the least number of iterations after which G is false and I(N) is true, then the value of the algorithm
variables will be as specified in the post-condition of the loop]

when the loop therminates the guard a > 0 will eventually become false
so a <= 0 eventually and a and A have the same parity

so if A is even -> a is even and <=0 since 0 is the closest number subtracting to 2 is 0
if A is odd -> a is odd and <=0 since -1 is the closest number reachable by subtracting 2 is -1

thus proven

11. the following while loop implements a way to multiply two numbers that was developed by the ancient egyptians
[pre-condition: A and B are positive integers, x = A, y = B, and product = 0]
    while y does not equal 0
    r:= y mod 2
    if r = 0
        then do x:= 2 . x
                y:= y div 2
        end do
    if r = 1
        then do product:= product + x
                y:=y-1
        end do
    end while
[post-condition: product = A.B]

a. make trace table to show that the algorithm gives the correct answer for multiplying A = 13 times B =18

initialization
x = 13
y = 18
product = 0

1st iteration
y = 0? false
set r:= 18 mod 2 = 0
is r 0? true
set x:= 2 . 13 = 26
set y:= 18 div 2 = 9

2nd iteration
y = 0? false
set r:= 9 mod 2 = 1
is r 0? false
set product:= 0 + 26
set y:=9-1=8

3rd iteration
y = 0? false
set r:= 8 mod 2 = 0
is r 0? true
set x:= 2 . 26 = 52
set y:= 8 div 2 = 4

4th iteration
y = 0? false
set r:= 4 mod 2 = 0
is r 0? true
set x:= 2 . 52 = 104
set y:= 4 div 2 = 2

5th iteration
y = 0? false
set r:= 2 mod 2 = 0
is r 0? true
set x:= 2 . 104 = 208
set y:= 2 div 2 = 1

6th iteration
y = 0? false
set r:= 1 mod 2 = 1
is r 0? false
set product:= 26 + 208
set y:=1-1=0

7th iteration
y = 0? true
end while
product = A . B = 234

b. prove the correctness of this lop with respect to its pre-adn-post conditions by using the loop invariant
I(n) = "xy + product = A . B"

I. BASIS PROPERTY:
[I(0) is true before the first iteration of the loop]
I(0) is "xy + product = A . B"
since we know from precondition that A and B are positive integers and product = 0
xy + 0 = A . B
x . y = A . B
and since we know that x = A and y = B we can substitute
A . B = A . B -> therefore the basis property I(0) is true


II. INDUCTIVE PROPERTY
[if G AND I(k) is true before a loop iteration where k>=0, then I(k+1) is true after the loop iteration]

suppose k is a nonnegative integer such that G and I(k) is true before iteration of the loop
then as execution reaches the top of the loop, the guard is passed
y does not equal 0 is true and the invariant
I(k) "xy + product = A . B" is true

case 1: y_old is even (r_old = 0)
x_new = 2 . x_old
y_new = y_old div 2
product_new = product_old (product isn't updated on this branch)
then we can substittue
x_new * y_new + product_new = A . B
(2 . x_old) * (y_old div 2) + product_old = A . B

since we assumed that y_old is even then
y_old = 2 . (y_old div 2)
therefore x_old * y_old = A . B


case 2: y_old is odd (r_old = 1)
product_new = product_old + x_old
y_new = y_old - 1
x_new = x_old (doesn't update x on this branch)

x_new * y_new + product_new = A . B
x_old * (y_old - 1) + (product_old) + x_old = A . B
= (x_old * y_old - x_old) + (product_old + x_old)
= x_old * y_old + 0 = A . B
= x_old * y_old = A . B

therefore both cases are true

III. EVENTUAL FALSITY OF THE GUARD
[after a finite number of iterations of the loop, G becomes false]
the guard G is the condition y does not equal 0 will become false
which means y will eventually reach 0

since on each iteration it depends on r (either odd or even)
if r = 0 we reduce the y by div 2
if r = 1 we reduce the y by decrementing it by 1
in both cases they are reduced 
this y will eventually reach 0

IV. CORRECTNESS OF THE POST-CONDITION
[if N is the least number of iterations after which G is false and I(N) is true, then the value of the algorithm
variables will be as specified in the post-condition of the loop]

when the loop therminates the guard y does not equal 0 will become false
so y = 0 eventually will be true and I(N) is true

I(n) = x_final * y_final + product_final = A . B
we can substitute y = 0
x_final * 0 + product_final = A . B
product_final = A . B

thus proven
completed