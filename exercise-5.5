Test yourself

1. a pre-condition for an algorithm is ___
and a post-condition for an algorithm is ___
answer:
a predicate that describes the initial state of the input variables for the algorithm
a predicate that describes the final state of the output variables for the algorithm


2.  A loop is defined as correct with respect to its 
pre- and post-conditions if, and only if, whenever 
the algorithm variables satisfy the pre-condition 
for the loop and the loop terminates after a finite 
number of steps, then ___
answer: the algorithm variables satify the post-condition for the loop

3. for each iteration of the loop, if a loop invariant is true before iteration of the loop,
then ___
answer: it is true after the iteration of the loop

4. given a while loop with guard G and a predicate i(n) if the folowing properties are true, then the loop is correct
with respect to its pre-and post conditions
a) the pre-cond for the loop implies that ___ before
the first iteration of the loop
b) for every integer k>= 0, if the guard g and the predicate i(k) are both true before an iteration of the loop,
then ___
c) after a finite number of iterations of the loop, ___
d) if N is the least number of iteration after which G is false and i(N) is true, then
the values of the algorithm variables will be as as specified ___
answer:
a) i(0) is true
b) l(k+1) is true after the iteration of the loop
c) the guard will eventually become false
d) in the post condition of the loop


exercise set 5.5
Exercises 1–5 contain a while loop and a predicate. In 
each case show that if the predicate is true before entry 
to the loop, then it is also true after exit from the loop.

1. loop:
while (m>=0 and m <= 100)
m:= m+1
n:= n-1
end while
predicate: m+n = 100

step 1: initialization
assume m+n = 100 before the loop begins
p(m,n) =  m+n = 100

step 2: maintenance
let m_old and n_old be the values of m and n at the start of an iteration
m_old + n_old = 100
m_old >= 0 and m_old <= 100

inside the loop
m_new = m_old + 1
n_new = n_old - 1

m_new + n_new = 100
= (m_old + 1) + (n_old - 1) = 100
= m_old + n_old = 100

therefore if the predicate is true before iteration, it remains true after iteration

step 3: termination
when the loop terminates, p(m,n) is still true because
the loop termintates when the while condition is false
that means either m < 0 or m > 100
The loop repeats while m is between 0 and 100 inclusive.
Because m keeps increasing, eventually m must exceed 100.
m will eventually exceed 100

2. loop:
while(m>= 0 and m<= 100)
m:=m+4
n:=n-2
end while
predicate: m+n is odd

step 1: initialization
assume m+n is odd before the loop begins
p(m,n) = m+n is odd

step 2: maintenance
let m_old and n_old be the values of m and n at the start of an iteration
so assume m_old + n_old is odd
m_old >= 0 and m_old <= 100

inside the loop
m_new = m_old + 4
n_new = n_old - 2

m_new + n_new is odd
= (m_old + 4) + (n_old - 2) is odd
= m_old + n_old + 2 is odd

since we assume m_old + n_old is old we can then substitute tha parity
= odd + 2 is odd
= odd + even is odd
since even + odd is alawys odd therefoer step 2 is true

step 3: termination
when the loop terminates, p(m,n) is still true because
since m+n was odd before the loop starts, and it never changed throughout the iteration,
we can conclude that ist still odd when the loop terminates


3. loop:
while (m>=0 and m<= 100)
m:= 3m
n:= 5n
end while
predicate: m^3 > n^2

step 1: initialization
assume m^3 > n^2 is true before the loop begins
p(m,n) -> m^3 > n^2

step 2: maintenance
let m_old and n_old be the values of m and n at the start of an iteration
assume m_old and n_old = m_old^3 > n_old^2
where m_old >=0 and m_old <= 100

then inside the loop
= m_new = 3 . m_old
= n_new = 5 . n_old

then we can substitute
m_new^3 > n_new^2
= (3 . m_old)^3 > (5 . n_old^2)
= 3^3 . m_old^3 > 5^2 . n_old^2
= 27 . m_old^3 > 25 . n_old^2

since we know that m_old^3 > n_old^2
multiplying both sides by 27 will hold
27 . m_old^3 > 27 . n_old^2

and since 27 >25 we know that
27. n_old^2 > 25 . n_old^2

therefore we know
27 . m_old^3 > 27 . n_old^2 > 25. n_old^2
therefore  if A > B and B > C then A > C by transivitiy so its true

step 3: termiation
when the loop terminates p(m,n) is still true because
since m^3 > n^2 was true before the loop starts and it never changed throughout the iteration
we can conclude that its still holds true even after the loop terminates

4. loop:
while (n >= 0 and n<= 100)
n:= n+1
end while
predicate: 2^n < (n+2)!

step 1: initialization
assume the predicate p(n) is true before the loop begins
p(n) = 2^n < (n+2)!

step 2: maintenance
let n_old be the values of n at the start of an iteration
2^n_old < (n_old+2)!
where n_old >= 100 and n_old <= 100

then inside of the loop
n_new = n_old + 1

then we can substitute
2^n_new < (n_new + 2)!
= 2^n_old+1 < ((n_old+1)+2)!
= 2 . 2^n_old < (n_old+3) . (n_old+2)!

focusing on 2 < (n_old+3)
since we know that n>= 0 and n<= 100
and the smallest value RHS can hold when n=0 is 3
so 2 < 3 therefore the inequality is true
therefore the inequality 2 . 2^n_old < (n_old+3) . (n_old+2)! holds


step 3: termination
when the loop terminates, p(n) is still tre because
since the predicate 2^n < (n+2)! was true before the loop starts and it never changed throughout the iteration
we can conclude that its still holds true even after the loop terminates

5. loop:
while (n>=3 and n<= 100)
n:= n+1
end while
predicate: 2n+1 <= 2^n

step 1: initialization
assume the predicate 2n+1 <= 2^n is true before the loop begins
p(n) -> 2n+1 <= 2^n

step 2: maintenance
let n_old be the values of n at the start of an iteration
so 2 . n_old + 1 <= 2^n_old
where 3 <= n_old <= 100

inside the loop
n_new = n_old + 1 (increment the index)

then run this predicate
2 . n_new + 1 < 2^n_new
= 2 . (n_old + 1) + 1 <  2^n_old+1
= 2 . n_old + 2 + 1 < 2 . 2^n_old
= 2 . n_old + 3  < 2 . 2^n_old

since we assumed 2 . n_old + 1 <= 2^n_old from IH,
we can multiply both sides by 2
4 . n_old + 2 <= 2 . 2^n_old

then we can compare
2 . n_old + 3 <= 4 . n_old + 2 
subtract 2 . n_old from both sides
3 <= 2 . n_old+2
subtract 2 from both sides
1 <= 2 . n_old
since we know n at a minimum is 3 we can substitute
1 <= 2 . 3
1 <= 6

since we know 2 . n_old + 3 <= 4 . n_old + 2 <= 2 . 2^n_old
therefore 2 . n_old + 3 <= 2 . 2^n_old equality holds

step 3: termination
when the loop terminates, p(n) is still tre because
since the predicate 2n+1 <= 2^n was true before the loop starts and it never changed throughout the iteration
we can conclude that its still holds true even after the loop terminates

exercises 6–9 each contain a while loop annotated with a 
pre- and a post-condition and also a loop invariant. In each 
case, use the loop invariant theorem to prove the correct
ness of the loop with respect to the pre- and post-conditions.

6.
[pre-condition: m is a nonnegative integer, x is a real number, i = 0 and exp = 1]
while (i does not equal m) 
1. exp:=exp.x
2. i:=i+1
end while
[post condition: exp=x^m]
loop invariant: I(n) is "exp = x^n and i = n"

answer:
let the loop invariant be  I(n) is "exp = x^n and i = n"
let the guard G be (i does not equal m)  

I. BASIS PROPERTY:
[I(0) is true before the first iteration of the loop]
I(0) is "exp = x^0 and i = n" -> exp = 1 and i = 0, therefore it is true before the first iteration of the loop

II. INDUCTIVE PROPERTY:
[if G AND I(k) is true before a loop iteration where k>=0,
then I(k+1) is true after the loop iteration]

suppse k is a nonnegative int such that G AND I(k) is true before iteration of the loop
then as execution reaches the top of the loop, i does not equal m and exp = x^k
since i does not equal m the guard is passed and statement 1 is executed
before execution of statement 1,

exp_old = x^k

then execution of statement 1 has the following effect
exp_new = exp_old . x
= x^k . x
= x^k+1

before statement 2 is executed
i_old = k
afer execution of statement 1 it becomes
i_new = i_old + 1

hence after the loop iteration, the statement i(k+1) (i = k+1 and exp=x^k+1) is therefore true

III. EVENTUAL FALSITY OF THE GUARD
[after a finite number of iterations of the loop, G becomes false]
the guard G is the condition i does not equal m, and m is a nonnegative integer
by 1 and 2 we know that
for every integer n>= 0, if the loop is iterated n times, then i = n and exp = x^n
so after m iterations of the loop i will eventually become m. thus G becomes false after m iterations of the loop

IV. CORRECTNESS OF THE POST-CONDITION
[if N is the least number of iterations after which G is false and I(N) is true, then the value of the algorithm
variables will be as specified in the post-condition of the loop]

when the loop terminates
the guard G becomes false, so i = m
the loop invariant I(N) holds: x^N and i = N
since i = m and i = n we conclude N = m
thus exp = x^N = x^m satisfying the post condition

thus proven

7.
[pre-condition: largest = A[1] and i = 1]
while (i does not equal m)
1. i:=i+1
2. if A[i] > largest then largest:= A[i]
end while
[post condition: largest = maximum value of A[1], A[2], A[3], A[4], ... A[m]]
loop invariant: I(n) is "largest = maximum value of A[1], A[2], ... A[n+1] and i = n + 1"

answer:
let the loop invariant be  I(n) is "exp = x^n and i = n"
let the guard G be (i does not equal m)  

I. BASIS PROPERTY:
[I(0) is true before the first iteration of the loop]
I(0) is "exp = x^0 and i = n" -> exp = 1 and i = 0, therefore it is true before the first iteration of the loop

II. INDUCTIVE PROPERTY:
[if G AND I(k) is true before a loop iteration where k>=0,
then I(k+1) is true after the loop iteration]

suppse k is a nonnegative int such that G AND I(k) is true before iteration of the loop
then as execution reaches the top of the loop, i does not equal m and exp = x^k
since i does not equal m the guard is passed and statement 1 is executed
before execution of statement 1,

exp_old = x^k

then execution of statement 1 has the following effect
exp_new = exp_old . x
= x^k . x
= x^k+1

before statement 2 is executed
i_old = k
afer execution of statement 1 it becomes
i_new = i_old + 1

hence after the loop iteration, the statement i(k+1) (i = k+1 and exp=x^k+1) is therefore true

III. EVENTUAL FALSITY OF THE GUARD
[after a finite number of iterations of the loop, G becomes false]
the guard G is the condition i does not equal m, and m is a nonnegative integer
by 1 and 2 we know that
for every integer n>= 0, if the loop is iterated n times, then i = n and exp = x^n
so after m iterations of the loop i will eventually become m. thus G becomes false after m iterations of the loop

IV. CORRECTNESS OF THE POST-CONDITION
[if N is the least number of iterations after which G is false and I(N) is true, then the value of the algorithm
variables will be as specified in the post-condition of the loop]

when the loop terminates
the guard G becomes false, so i = m
the loop invariant I(N) holds: x^N and i = N
since i = m and i = n we conclude N = m
thus exp = x^N = x^m satisfying the post condition

thus proven

8. 

