Test yourself

1. a pre-condition for an algorithm is ___
and a post-condition for an algorithm is ___
answer:
a predicate that describes the initial state of the input variables for the algorithm
a predicate that describes the final state of the output variables for the algorithm


2.  A loop is defined as correct with respect to its 
pre- and post-conditions if, and only if, whenever 
the algorithm variables satisfy the pre-condition 
for the loop and the loop terminates after a finite 
number of steps, then ___
answer: the algorithm variables satify the post-condition for the loop

3. for each iteration of the loop, if a loop invariant is true before iteration of the loop,
then ___
answer: it is true after the iteration of the loop

4. given a while loop with guard G and a predicate i(n) if the folowing properties are true, then the loop is correct
with respect to its pre-and post conditions
a) the pre-cond for the loop implies that ___ before
the first iteration of the loop
b) for every integer k>= 0, if the guard g and the predicate i(k) are both true before an iteration of the loop,
then ___
c) after a finite number of iterations of the loop, ___
d) if N is the least number of iteration after which G is false and i(N) is true, then
the values of the algorithm variables will be as as specified ___
answer:
a) i(0) is true
b) l(k+1) is true after the iteration of the loop
c) the guard will eventually become false
d) in the post condition of the loop


exercise set 5.5
Exercises 1â€“5 contain a while loop and a predicate. In 
each case show that if the predicate is true before entry 
to the loop, then it is also true after exit from the loop.

1. loop:
while (m>=0 and m <= 100)
m:= m+1
n:= n-1
end while
predicate: m+n = 100

step 1: initialization
assume m+n = 100 before the loop begins
p(m,n) =  m+n = 100

step 2: maintenance
let m_old and n_old be the values of m and n at the start of an iteration
m_old + n_old = 100
m_old >= 0 and m_old <= 100

inside the loop
m_new = m_old + 1
n_new = n_old - 1

m_new + n_new = 100
= (m_old + 1) + (n_old - 1) = 100
= m_old + n_old = 100

therefore if the predicate is true before iteration, it remains true after iteration

step 3: termination
when the loop terminates, p(m,n) is still true because
the loop termintates when the while condition is false
that means either m < 0 or m > 100
The loop repeats while m is between 0 and 100 inclusive.
Because m keeps increasing, eventually m must exceed 100.
m will eventually exceed 100

2. loop:
while(m>= 0 and m<= 100)
m:=m+4
n:=n-2
end while
predicate: m+n is odd

step 1: initialization
assume m+n is odd before the loop begins
p(m,n) = m+n is odd

step 2: maintenance
let m_old and n_old be the values of m and n at the start of an iteration
so assume m_old + n_old is odd
m_old >= 0 and m_old <= 100

inside the loop
m_new = m_old + 4
n_new = n_old - 2

m_new + n_new is odd
= (m_old + 4) + (n_old - 2) is odd
= m_old + n_old + 2 is odd

since we assume m_old + n_old is old we can then substitute tha parity
= odd + 2 is odd
= odd + even is odd
since even + odd is alawys odd therefoer step 2 is true

step 3: termination
when the loop terminates, p(m,n) is still true because
since m+n was odd before the loop starts, and it never changed throughout the iteration,
we can conclude that ist still odd when the loop terminates


3. loop:
while (m>=0 and m<= 100)
m:= 3m
n:= 5n
end while
predicate: m^3 > n^2

step 1: initialization
assume m^3 > n^2 is true before the loop begins
p(m,n) -> m^3 > n^2

step 2: maintenance
let m_old and n_old be the values of m and n at the start of an iteration
assume m_old and n_old = m_old^3 > n_old^2
where m_old >=0 and m_old <= 100

then inside the loop
= m_new = 3 . m_old
= n_new = 5 . n_old

then we can substitute
m_new^3 > n_new^2
= (3 . m_old)^3 > (5 . n_old^2)
= 3^3 . m_old^3 > 5^2 . n_old^2
= 27 . m_old^3 > 25 . n_old^2

since we know that m_old^3 > n_old^2
multiplying both sides by 27 will hold
27 . m_old^3 > 27 . n_old^2

and since 27 >25 we know that
27. n_old^2 > 25 . n_old^2

therefore we know
27 . m_old^3 > 27 . n_old^2 > 25. n_old^2
therefore  if A > B and B > C then A > C by transivitiy so its true

step 3: termiation
when the loop terminates p(m,n) is still true because
since m^3 > n^2 was true before the loop starts and it never changed throughout the iteration
we can conclude that its still holds true even after the loop terminates

4. loop:
while (n >= 0 and n<= 100)
n:= n+1
end while
predicate: 2^n < (n+2)!

step 1: initialization
assume the predicate p(n) is true before the loop begins
p(n) = 2^n < (n+2)!

step 2: maintenance
let n_old be the values of n at the start of an iteration
2^n_old < (n_old+2)!
where n_old >= 100 and n_old <= 100

then inside of the loop
n_new = n_old + 1

then we can substitute
2^n_new < (n_new + 2)!
= 2^n_old+1 < ((n_old+1)+2)!
= 2 . 2^n_old+1 < ((n_old+1)+2) . ((n_old+1)+1)!
= ???

step 3: termination

5. loop:
while (n>=3 and n<= 100)
n:= n+1
end while
predicate: 2n+1 <= 2^n